{
  "name": "gmail-to-telegram",
  "nodes": [
    {
      "parameters": {
        "operation": "getAll",
        "limit": 1,
        "simple": false,
        "filters": {
          "readStatus": "unread",
          "receivedAfter": "={{ $today.minus(2, 'day').startOf('day').toISO() }}"
        },
        "options": {}
      },
      "id": "get-gmail-messages",
      "name": "Get Unread Emails",
      "type": "n8n-nodes-base.gmail",
      "position": [464, 304],
      "webhookId": "de438789-71b6-421a-b4ec-c8ff234aa80f",
      "typeVersion": 2,
      "alwaysOutputData": true,
      "credentials": {
        "gmailOAuth2": {
          "id": "52sKMHofP7P9AGpR",
          "name": "Gmail account"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "version": 1,
            "leftValue": "",
            "caseSensitive": true,
            "typeValidation": "strict"
          },
          "combinator": "and",
          "conditions": [
            {
              "id": "condition-has-emails",
              "operator": {
                "type": "number",
                "operation": "gt"
              },
              "leftValue": "={{ $input.all().length }}",
              "rightValue": 0
            },
            {
              "id": "090360f7-5b35-4376-b041-18fb1eb89a46",
              "operator": {
                "type": "object",
                "operation": "notEmpty",
                "singleValue": true
              },
              "leftValue": "={{ $input.first() }}",
              "rightValue": ""
            }
          ]
        },
        "options": {}
      },
      "id": "check-emails-exist",
      "name": "Any Emails?",
      "type": "n8n-nodes-base.if",
      "position": [656, 304],
      "typeVersion": 2,
      "alwaysOutputData": false
    },
    {
      "parameters": {
        "jsCode": "// Single Code node: per-email Telegram messages + final daily summary\n// Uses ONLY the JSON inside `response` for each input item.\n\n// Return type matches n8n's N8nOutputItems interface\n// Each item should have: { json: Object, binary?: Object }\n\n// ---------- helpers ----------\n\n/**\n * Extracts JSON object from LLM response with robust parsing\n * Handles various formats: plain JSON, markdown code blocks, mixed text\n * @param {*} rawResponse - The raw response from LLM\n * @returns {Object} Parsed JSON object or empty object on failure\n */\nfunction extractJsonFromResponse(rawResponse) {\n  if (rawResponse == null) return {};\n  if (typeof rawResponse === \"object\") return rawResponse;\n  if (typeof rawResponse !== \"string\") return {};\n\n  // Try direct JSON parse first (fastest path)\n  try {\n    return JSON.parse(rawResponse);\n  } catch {\n    // Continue to more complex extraction methods\n  }\n\n  const response = rawResponse.trim();\n\n  // Method 1: Extract from markdown code blocks with optional language\n  const codeBlockRegex = /```(?:json)?\\s*(\\{[\\s\\S]*?\\})\\s*```/i;\n  const codeBlockMatch = response.match(codeBlockRegex);\n  if (codeBlockMatch) {\n    try {\n      return JSON.parse(codeBlockMatch[1]);\n    } catch (e) {\n      console.warn(`Failed to parse JSON from code block: ${e.message}`);\n    }\n  }\n\n  // Method 2: Extract first JSON-like object from response\n  const jsonObjectRegex = /(\\{(?:[^{}]|{[^{}]*})*\\})/;\n  const jsonMatch = response.match(jsonObjectRegex);\n  if (jsonMatch) {\n    try {\n      return JSON.parse(jsonMatch[1]);\n    } catch (e) {\n      console.warn(`Failed to parse extracted JSON: ${e.message}`);\n    }\n  }\n\n  // Method 3: Look for JSON after common LLM prefixes\n  const commonPrefixes = [\n    \"Here is the JSON output based on the provided email:\",\n    \"Here is the JSON output:\",\n    \"The JSON output:\",\n    \"```json\",\n    \"```\",\n    \"Output:\",\n    \"Result:\",\n  ];\n\n  for (const prefix of commonPrefixes) {\n    const index = response.toLowerCase().indexOf(prefix.toLowerCase());\n    if (index !== -1) {\n      const afterPrefix = response.substring(index + prefix.length).trim();\n      const prefixJsonMatch = afterPrefix.match(jsonObjectRegex);\n      if (prefixJsonMatch) {\n        try {\n          return JSON.parse(prefixJsonMatch[1]);\n        } catch (e) {\n          continue;\n        }\n      }\n    }\n  }\n\n  console.warn(\n    `Could not extract valid JSON from LLM response. Response preview: ${response.substring(\n      0,\n      100\n    )}...`\n  );\n  return {};\n}\n\n/**\n * Legacy function for backward compatibility\n * @deprecated Use extractJsonFromResponse instead\n */\nfunction toObj(r) {\n  return extractJsonFromResponse(r);\n}\n\n/**\n * Cleans and normalizes sender name from email\n * Removes email addresses in angle brackets and pipe-separated domains\n * @param {string} senderName - Raw sender name from email\n * @returns {string} Cleaned sender name\n */\nfunction cleanFromName(senderName) {\n  if (!senderName) return \"Unknown sender\";\n\n  let cleaned = String(senderName).trim();\n\n  // Remove email address in angle brackets: \"John Doe <john@example.com>\"\n  if (cleaned.includes(\"<\")) {\n    cleaned = cleaned.split(\"<\")[0].trim();\n  }\n\n  // Remove domain after pipe: \"John Doe | Example.com\"\n  if (cleaned.includes(\"|\")) {\n    cleaned = cleaned.split(\"|\")[0].trim();\n  }\n\n  // Remove surrounding quotes\n  cleaned = cleaned.replace(/^[\"']|[\"']$/g, \"\");\n\n  return cleaned || \"Unknown sender\";\n}\n\n/**\n * Formats action items into markdown list with proper link handling\n * @param {Array<string|Object>} actions - Array of action items\n * @returns {string} Formatted actions block or empty string\n */\nfunction formatActions(actions) {\n  if (!Array.isArray(actions) || actions.length === 0) {\n    return \"\";\n  }\n\n  const URL_REGEX = /https?:\\/\\/\\S+/;\n\n  const formattedActions = actions\n    .map((action) => {\n      if (typeof action === \"string\") {\n        return formatStringAction(action, URL_REGEX);\n      } else if (action && typeof action === \"object\") {\n        return formatObjectAction(action);\n      }\n      return null;\n    })\n    .filter(Boolean);\n\n  return formattedActions.length > 0\n    ? `\\n\\nActions:\\n${formattedActions.join(\"\\n\")}`\n    : \"\";\n}\n\n/**\n * Formats string-based action item\n * @param {string} action - Action string (may contain \"Label: URL\" format)\n * @param {RegExp} urlRegex - URL matching regex\n * @returns {string} Formatted action item\n */\nfunction formatStringAction(action, urlRegex) {\n  // Handle \"Label: URL\" format\n  if (action.includes(\":\")) {\n    const [label, ...urlParts] = action.split(\":\");\n    const urlPart = urlParts.join(\":\").trim();\n    const urlMatch = urlPart.match(urlRegex);\n\n    if (urlMatch) {\n      return `- [${label.trim()}](${urlMatch[0]})`;\n    }\n  }\n\n  // Handle direct URL in text\n  const urlMatch = action.match(urlRegex);\n  if (urlMatch) {\n    return `- [Open link](${urlMatch[0]})`;\n  }\n\n  // Plain text action\n  return `- ${action}`;\n}\n\n/**\n * Formats object-based action item\n * @param {Object} action - Action object with label/title and url/href properties\n * @returns {string} Formatted action item\n */\nfunction formatObjectAction(action) {\n  const label = action.label || action.title || \"Open link\";\n  const url = action.url || action.href;\n\n  return url ? `- [${label}](${url})` : `- ${label}`;\n}\n\n/**\n * Validates and normalizes email data from LLM response\n * @param {Object} emailData - Raw email data object\n * @returns {Object} Validated and normalized email data\n */\nfunction validateEmailData(emailData) {\n  const defaults = {\n    isImportant: false,\n    from: \"Unknown sender\",\n    subject: \"No subject\",\n    category: \"Uncategorized\",\n    receivedDate: new Date().toISOString(),\n    gmailUrl: \"#\",\n    summary: \"No summary available\",\n    actions: [],\n  };\n\n  return {\n    isImportant: Boolean(emailData.isImportant),\n    from: cleanFromName(emailData.from || defaults.from),\n    subject: String(emailData.subject || defaults.subject),\n    category: String(emailData.category || defaults.category),\n    receivedDate: emailData.receivedDate || defaults.receivedDate,\n    gmailUrl: emailData.gmailUrl || defaults.gmailUrl,\n    summary: String(emailData.summary || defaults.summary),\n    actions: Array.isArray(emailData.actions)\n      ? emailData.actions\n      : defaults.actions,\n  };\n}\n\n/**\n * Creates formatted email message from validated data\n * @param {Object} emailData - Validated email data\n * @returns {string} Formatted message string\n */\nfunction createEmailMessage(emailData) {\n  const { from, subject, category, receivedDate, summary, actions, gmailUrl } =\n    emailData;\n  const actionsBlock = formatActions(actions);\n  const formattedDate = new Date(receivedDate).toLocaleString();\n\n  return `[${from}]: ${subject}\nCategory: ${category}\nReceived: ${formattedDate}\n\n${summary}${actionsBlock}\n\n[Open in Gmail](${gmailUrl})`;\n}\n\n// ---------- main ----------\nconst items = $input.all();\n\n// Early validation\nif (!items || !Array.isArray(items)) {\n  console.error(\"Invalid input: Expected array of items\");\n  return [\n    {\n      json: {\n        message: \"‚ùå Error: Invalid input data provided to email mapper\",\n        error: true,\n        isSummary: true,\n      },\n    },\n  ];\n}\n\nconst perEmailOutputs = [];\nconst aggregationStats = {\n  total: 0,\n  important: 0,\n  byCategory: new Map(), // Using Map for better performance\n  importantList: [],\n  errors: 0,\n};\n\nfor (const item of items) {\n  try {\n    // Support both AI Agent (direct JSON in .output) and HTTP Request (.response string)\n    const rawData = item?.json?.output || item?.json?.response || item?.json;\n\n    if (!rawData) {\n      console.warn(\"Skipping item with no data:\", item);\n      aggregationStats.errors++;\n      continue;\n    }\n\n    const extractedData = extractJsonFromResponse(rawData);\n    const validatedEmail = validateEmailData(extractedData);\n\n    // Update aggregation stats\n    aggregationStats.total++;\n    if (validatedEmail.isImportant) {\n      aggregationStats.important++;\n      aggregationStats.importantList.push({\n        subject: validatedEmail.subject,\n        from: validatedEmail.from,\n      });\n    }\n\n    // Track categories (using Map for better performance)\n    const currentCount =\n      aggregationStats.byCategory.get(validatedEmail.category) || 0;\n    aggregationStats.byCategory.set(validatedEmail.category, currentCount + 1);\n\n    // Create formatted message\n    const message = createEmailMessage(validatedEmail);\n\n    const outputItem = {\n      json: {\n        message,\n        isImportant: validatedEmail.isImportant,\n        subject: validatedEmail.subject,\n        from: validatedEmail.from,\n        category: validatedEmail.category,\n        receivedDate: validatedEmail.receivedDate,\n        gmailUrl: validatedEmail.gmailUrl,\n        summary: validatedEmail.summary,\n        actions: validatedEmail.actions,\n        isSummary: false,\n      },\n    };\n\n    perEmailOutputs.push(outputItem);\n  } catch (error) {\n    console.error(\"Error processing email item:\", error);\n    aggregationStats.errors++;\n    // Continue processing other emails instead of failing completely\n  }\n}\n\n/**\n * Creates daily summary message from aggregation stats\n * @param {Object} stats - Aggregation statistics\n * @returns {Object} Summary message object\n */\nfunction createDailySummary(stats) {\n  const finishedAt = new Date().toLocaleString();\n\n  // Handle no emails case\n  if (stats.total === 0) {\n    return {\n      message: \"üìß Daily Gmail scan complete ‚Äî no new emails found.\",\n      totalEmails: 0,\n      importantEmails: 0,\n      byCategory: {},\n      errors: stats.errors,\n      finishedAt,\n      isSummary: true,\n    };\n  }\n\n  // Build category breakdown (convert Map to sorted array)\n  const categoryEntries = Array.from(stats.byCategory.entries())\n    .sort(([, a], [, b]) => b - a)\n    .map(([category, count]) => `‚Ä¢ ${category}: ${count}`)\n    .join(\"\\n\");\n\n  // Build top important emails list\n  const topImportantLines = stats.importantList\n    .slice(0, 5)\n    .map((email) => `- **${email.subject}** ‚Äî ${email.from}`)\n    .join(\"\\n\");\n\n  // Construct summary message\n  let summaryMessage = `üìä **Daily Gmail Summary**\n\nüìß Total emails processed: ${stats.total}\nüî¥ Important emails: ${stats.important}`;\n\n  if (stats.errors > 0) {\n    summaryMessage += `\\n‚ö†Ô∏è Processing errors: ${stats.errors}`;\n  }\n\n  if (categoryEntries) {\n    summaryMessage += `\\n\\n**By category:**\\n${categoryEntries}`;\n  }\n\n  if (topImportantLines) {\n    summaryMessage += `\\n\\n**Top important:**\\n${topImportantLines}`;\n  }\n\n  summaryMessage += `\\n\\n‚úÖ Individual summaries were sent above.\n\n_Scan completed at ${finishedAt}_`;\n\n  return {\n    message: summaryMessage,\n    totalEmails: stats.total,\n    importantEmails: stats.important,\n    byCategory: Object.fromEntries(stats.byCategory), // Convert Map back to object for compatibility\n    errors: stats.errors,\n    finishedAt,\n    isSummary: true,\n  };\n}\n\n// Create and append daily summary\nconst summary = createDailySummary(aggregationStats);\nconst summaryItem = {\n  json: summary,\n};\nperEmailOutputs.push(summaryItem);\n\nreturn perEmailOutputs;\n"
      },
      "id": "format-telegram-message",
      "name": "Format for Telegram",
      "type": "n8n-nodes-base.code",
      "position": [1552, 304],
      "typeVersion": 2
    },
    {
      "parameters": {
        "chatId": "={{ 219678893 }}",
        "text": "={{ $json.message }}",
        "additionalFields": {
          "appendAttribution": false
        }
      },
      "id": "send-telegram-message",
      "name": "Send to Telegram",
      "type": "n8n-nodes-base.telegram",
      "position": [1728, 304],
      "webhookId": "bb5d0404-e164-49b9-8f65-2df8d5aa2e10",
      "typeVersion": 1.2,
      "credentials": {
        "telegramApi": {
          "id": "h7RbmzMEg5YYOgNt",
          "name": "Emails Summary Bot"
        }
      }
    },
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "triggerAtHour": 2
            }
          ]
        }
      },
      "id": "c54f948e-47f4-486a-a897-94c4a11b09fd",
      "name": "Schedule Trigger",
      "type": "n8n-nodes-base.scheduleTrigger",
      "position": [272, 304],
      "typeVersion": 1.2
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "e0f5d3a2-366b-44db-9dd3-033d6b9f7a80",
              "name": "id",
              "type": "string",
              "value": "={{ $json.id }}"
            },
            {
              "id": "e22e7ea8-4364-426d-a457-afce4bfa6625",
              "name": "to",
              "type": "string",
              "value": "={{ $json.to.text }}"
            },
            {
              "id": "0c71a3c0-6aff-4336-b82f-4c21fc514cd9",
              "name": "fromAddress",
              "type": "string",
              "value": "={{ $json.from.value[0].address }}"
            },
            {
              "id": "42822dc7-4c9b-433c-8965-d326036dad98",
              "name": "fromName",
              "type": "string",
              "value": "={{ $json.from.value[0].name }}"
            },
            {
              "id": "b6a55194-7dcb-4f0a-a048-b09eef1ce6e6",
              "name": "subject",
              "type": "string",
              "value": "={{ $json.subject }}"
            },
            {
              "id": "ea1c5a43-f3fa-4af5-ba9d-ecd3946ba6a8",
              "name": "text",
              "type": "string",
              "value": "={{ $json.text }}"
            },
            {
              "id": "94a8bb73-3ac0-4721-ba0a-f0d585810bd3",
              "name": "gmailUrl",
              "type": "string",
              "value": "=https://mail.google.com/mail/u/0/#inbox/{{ $json.threadId }}"
            },
            {
              "id": "d6341c88-1aca-4007-995d-cc34e7019247",
              "name": "internalDate",
              "type": "string",
              "value": "={{ $json.date }}"
            }
          ]
        },
        "options": {}
      },
      "id": "161185c0-b1df-4bf0-80c9-b6d141765760",
      "name": "Map Email Fields",
      "type": "n8n-nodes-base.set",
      "position": [928, 304],
      "typeVersion": 3.4
    },
    {
      "parameters": {
        "options": {
          "reset": false
        }
      },
      "id": "ebafcb48-c359-4567-8ef9-df65207b4e7b",
      "name": "Loop Over Emails",
      "type": "n8n-nodes-base.splitInBatches",
      "position": [1216, 304],
      "typeVersion": 3
    },
    {
      "parameters": {
        "method": "POST",
        "url": "http://ollama:11434/api/generate",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "model",
              "value": "llama3.2:3b"
            },
            {
              "name": "prompt",
              "value": "=Summarize the following email according to the system instructions.\n\nTo: {{ $json.to }}\nFrom: {{ $json.fromAddress }} | {{ $json.fromName }}\nSubject: {{ $json.subject }}\nGmail URL: {{ $json.gmailUrl }}\nReceived: {{ $json.internalDate }}\n\nText:\n{{ $json.text }}"
            },
            {
              "name": "stream",
              "value": false
            },
            {
              "name": "system",
              "value": "You are an email analysis agent. Your goal is to analyze an email and produce a structured JSON object describing its key attributes.\n\nFollow these rules strictly:\n1. Summarize the email concisely in plain language (no speculation).\n2. Extract up to 5 actionable items ‚Äî each must be either:\n  - a short descriptive label with a valid URL starting with http or https, or\n  - plain text if no URL is present.\n3. Determine whether the email is important (true / false).\n4. Assign one category from this fixed list or create a new one:\n\nwork, meeting, personal, finance, travel, delivery,\nnotification, promotion, event, education, support, unknown\n\n\n5. If any field cannot be determined, return \"unknown\" or null.\n6. Do not invent or hallucinate any data.\n7. CRITICAL: Output ONLY valid JSON following the exact schema below. Do NOT include any explanatory text, code blocks, backticks, or commentary before or after the JSON.\n8. Your response must start with '{' and end with '}' - nothing else.\n\nExpected JSON format:\n{\n  \"subject\": \"string|null\",\n  \"from\": \"string|null\",\n  \"isImportant\": true,\n  \"summary\": \"string|null\",\n  \"category\": \"string|null\",\n  \"actions\": [\n    {\"label\": \"string\", \"url\": \"string\"}   // or a simple string action\n  ],\n  \"gmailUrl\": \"string|null\",\n  \"receivedDate\": \"string|null\"            // ISO8601, e.g. 2025-10-20T19:30:48Z\n}\n\nExample output:\n{\n  \"subject\": \"Invoice for October\",\n  \"from\": \"Acme Billing <billing@acme.com>\",\n  \"isImportant\": true,\n  \"summary\": \"Your October invoice is ready for payment.\",\n  \"category\": \"finance\",\n  \"actions\": [\n    {\"label\": \"View Invoice\", \"url\": \"https://acme.com/invoices/123\"},\n    {\"label\": \"Pay Now\", \"url\": \"https://acme.com/pay/123\"}\n  ],\n  \"gmailUrl\": \"https://mail.google.com/mail/u/0/#inbox/ABC123\",\n  \"receivedDate\": \"2025-10-24T09:41:12Z\"\n}"
            },
            {
              "name": "format",
              "value": "json"
            }
          ]
        },
        "options": {
          "timeout": 3600000
        }
      },
      "id": "analyze-email-llm",
      "name": "Summarise Email with LLM",
      "type": "n8n-nodes-base.httpRequest",
      "position": [1248, 560],
      "typeVersion": 4.2
    },
    {
      "parameters": {
        "chatId": "={{ 219678893 }}",
        "text": "üìß Daily Gmail scan complete - no new emails found.",
        "additionalFields": {
          "appendAttribution": false
        }
      },
      "id": "b01cc065-ac24-4dfa-8e6a-9dffc1df56dd",
      "name": "Send a text message1",
      "type": "n8n-nodes-base.telegram",
      "position": [928, 480],
      "webhookId": "ea8088a1-7a12-4dc2-b691-9e3d3d37cab1",
      "typeVersion": 1.2,
      "credentials": {
        "telegramApi": {
          "id": "h7RbmzMEg5YYOgNt",
          "name": "Emails Summary Bot"
        }
      }
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=Summarize the following email according to the system instructions.\n\nTo: {{ $json.to }}\nFrom: {{ $json.fromAddress }} | {{ $json.fromName }}\nSubject: {{ $json.subject }}\nGmail URL: {{ $json.gmailUrl }}\nReceived: {{ $json.internalDate }}\n\nText:\n{{ $json.text }}",
        "options": {
          "systemMessage": "=You are an email analysis agent. Your goal is to analyze an email and produce a structured JSON object describing its key attributes.\n\nFollow these rules strictly:\n1. Summarize the email concisely in plain language (no speculation).\n2. Extract up to 5 actionable items ‚Äî each must be either:\n  - a short descriptive label with a valid URL starting with http or https, or\n  - plain text if no URL is present.\n3. Determine whether the email is important (true / false).\n4. Assign one category from this fixed list or create a new one:\n\nwork, meeting, personal, finance, travel, delivery,\nnotification, promotion, event, education, support, unknown\n\n\n5. If any field cannot be determined, return \"unknown\" or null.\n6. Do not invent or hallucinate any data.\n7. Output only valid JSON, following exactly the schema below ‚Äî no extra text or commentary.\n\nExpected JSON format:\n{\n  \"subject\": \"string|null\",\n  \"from\": \"string|null\",\n  \"isImportant\": true,\n  \"summary\": \"string|null\",\n  \"category\": \"string|null\",\n  \"actions\": [\n    {\"label\": \"string\", \"url\": \"string\"}   // or a simple string action\n  ],\n  \"gmailUrl\": \"string|null\",\n  \"receivedDate\": \"string|null\"            // ISO8601, e.g. 2025-10-20T19:30:48Z\n}\n\nExample output:\n{\n  \"subject\": \"Invoice for October\",\n  \"from\": \"Acme Billing <billing@acme.com>\",\n  \"isImportant\": true,\n  \"summary\": \"Your October invoice is ready for payment.\",\n  \"category\": \"finance\",\n  \"actions\": [\n    {\"label\": \"View Invoice\", \"url\": \"https://acme.com/invoices/123\"},\n    {\"label\": \"Pay Now\", \"url\": \"https://acme.com/pay/123\"}\n  ],\n  \"gmailUrl\": \"https://mail.google.com/mail/u/0/#inbox/ABC123\",\n  \"receivedDate\": \"2025-10-24T09:41:12Z\"\n}",
          "enableStreaming": false
        }
      },
      "id": "eb6c5551-5f1e-4a51-bdde-9c693ae78de8",
      "name": "AI Agent",
      "type": "@n8n/n8n-nodes-langchain.agent",
      "position": [1488, 512],
      "typeVersion": 2.2
    },
    {
      "parameters": {
        "model": "llama3.2:3b",
        "options": {
          "temperature": 0.2,
          "topP": 0.9,
          "keepAlive": "2m",
          "numThread": 4,
          "repeatPenalty": 1.1,
          "format": "json"
        }
      },
      "id": "02311d68-2cbe-4026-bad8-525426237099",
      "name": "Ollama Chat Model",
      "type": "@n8n/n8n-nodes-langchain.lmChatOllama",
      "position": [1488, 704],
      "typeVersion": 1,
      "credentials": {
        "ollamaApi": {
          "id": "eQ3cvhxCtXxqOlT5",
          "name": "Local Ollama"
        }
      }
    }
  ],
  "pinData": {},
  "connections": {
    "Get Unread Emails": {
      "main": [
        [
          {
            "node": "Any Emails?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Any Emails?": {
      "main": [
        [
          {
            "node": "Map Email Fields",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Send a text message1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Format for Telegram": {
      "main": [
        [
          {
            "node": "Send to Telegram",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Send to Telegram": {
      "main": [[]]
    },
    "Schedule Trigger": {
      "main": [
        [
          {
            "node": "Get Unread Emails",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Map Email Fields": {
      "main": [
        [
          {
            "node": "Loop Over Emails",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Loop Over Emails": {
      "main": [
        [
          {
            "node": "Format for Telegram",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Summarise Email with LLM",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Summarise Email with LLM": {
      "main": [
        [
          {
            "node": "Loop Over Emails",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Ollama Chat Model": {
      "ai_languageModel": [
        [
          {
            "node": "AI Agent",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "AI Agent": {
      "main": [[]]
    }
  },
  "active": true,
  "settings": {
    "executionOrder": "v1",
    "saveExecutionProgress": true,
    "callerPolicy": "workflowsFromSameOwner",
    "availableInMCP": false,
    "errorWorkflow": "5YHHqqqLCxRFvISB"
  },
  "versionId": "28b581e8-a4c1-4626-b5d8-8ddabc297267",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "f6850b7a742915e4beea1da1d7e81ab301286f32549db44a9ced290422cc1c31"
  },
  "id": "5YHHqqqLCxRFvISB",
  "tags": [
    {
      "createdAt": "2024-01-01T00:00:00.000Z",
      "updatedAt": "2024-01-01T00:00:00.000Z",
      "id": "gmail-automation",
      "name": "Gmail Automation"
    }
  ]
}
